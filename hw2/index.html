<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      h1 {
        text-align: center;
      }

      .container {
        margin: 0 auto;
        padding: 60px 20%;
      }

      figure {
        text-align: center;
      }

      img {
        display: inline-block;
      }

      body {
        font-family: "Inter", sans-serif;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
      <div style="text-align: center">Name: Jinkang Fang</div>

      <br />

      Link to webpage:
      <a href="https://cal-cs184-student.github.io/hw-webpages-avooocado/"
        >cal-cs184-student.github.io/hw-webpages-avooocado/</a
      >

      <br />

      Link to GitHub repository:
      <a href="https://github.com/cal-cs184-student/sp25-hw2-dragonfruit"
        >github.com/cal-cs184-student/sp25-hw2-dragonfruit</a
      >

      <!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

      <h2>Overview</h2>
      Give a high-level overview of what you implemented in this homework. Think
      about what you've built as a whole. Share your thoughts on what
      interesting things you've learned from completing the homework.

      <h2>Section I: Bezier Curves and Surfaces</h2>

      <h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

      A Bezier curve is a curve generated by interpolating between a series of
      points, called "control points." One way of evaluating them
      computationally is with the de Casteljau subdivision algorithm.
      <br /><br />

      The de Casteljau's algorithm applies 1D lerp to each consecutive pair of
      control points, and it does so recursively with each subdivision until we
      arrive at one point. Evaluating this algorithm on many \(t\) values yields
      a batch of points on the curve, which we can then chain together with
      straight lines to approximate the visual of the Bezier curve.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/bezier_curve0.png" width="400px" />
              <figcaption>Control points only.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/bezier_curve1.png" width="400px" />
              <figcaption>Step 1.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/bezier_curve2.png" width="400px" />
              <figcaption>Step 2.</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/bezier_curve3.png" width="400px" />
              <figcaption>Step 3.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/bezier_curve4.png" width="400px" />
              <figcaption>Step 4.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/bezier_curve5.png" width="400px" />
              <figcaption>Step 5.</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/bezier_curve6.png" width="400px" />
              <figcaption>With final curve.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/bezier_curve7.png" width="400px" />
              <figcaption>Different control point and \(t\).</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>

      Bezier surfaces are composed of rectangular patches of control points.
      When pieced together, they can create complex, curved structures, like the
      teapot shown below.
      <br /><br />
      To evaluate Bezier surfaces, we first need to figure out how to evaluate
      Bezier patches. To begin, we can apply the de Casteljau algorithm on each
      "row" of the control points, parameterized by some \(u\) in the range
      \([0,1]\). Doing this yields a new set of intermediate control points that
      we can conceptualize as a "column." Applying de Casteljau one more time on
      this "column" of control points parameterized by \(v\) (also in the range
      \([0,1]\)) gives us an evaluated point. Using this method, we can evaluate
      any point on a Bezier patch. Of course, without loss of generality, it
      doesn't really matter which orientation is the "row" or the "column," both
      ways will work.
      <br /><br />
      Using this method, we can apply this to all patches of a Bezier surface to
      compose a mesh, which is composed of triangles, which we can rasterize
      optimally.
      <br />
      <br />

      <img src="images/teapot_bez.png" width="400" />

      <h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

      <h3>Part 3: Area-weighted vertex normals</h3>

      An area-weighted vertex normal is a type of vertex normal where its
      direction is influenced by the area of the faces that the vertex is a part
      of, good for shading computations.
      <br /><br />
      To compute it, we can first consider finding the normals of the vertex's
      surrounding faces. Definitionally, a face's normal is a vector
      perpendicular to the face at any point. One way we can compute this is
      simply taking the cross product of two sides of the face. Consequently,
      the area of the face is exactly half the magnitude of this cross product,
      making it area-weighted by default! Therefore, we can simply sum the
      area-weighted normals of each neighboring face, then normalize that sum to
      obtain the area-weighted vertex normal.
      <br /><br />
      Since we are using the halfedge data structure, we can easily traverse
      neighboring faces from a given vertex using a do-while loop. In fact, we
      don't even need to reference the face itself, we just need to get the
      vertices of the neighboring faces for the computation. Here's a simple
      description of the traversal: starting from a halfedge that points out
      from the given vertex, keep going around in a circle to find the vertices
      of the neighboring faces until we end back at the start.
      <br /><br />
      Using area-weighted vertex normals, we can apply Phong-shading
      calculations to achieve a smooth shading effect on our teapot.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/teapot_normal_shading.png" width="400px" />
              <figcaption>Without vertex normal.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/teapot_phong_shading.png" width="400px" />
              <figcaption>With vertex normal.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Part 4: Edge flip</h3>

      Edge flips require a lot of careful pointer reassignments. But, that's all
      there is to it, just reassignments. It's easy to do if you draw a before
      and after diagram of the edge flip operation, labeling every mesh element:
      halfedge, edge, face, and vertex. After that, it's just making sure that
      edges, faces, and vertices have the right halfedge reassigned, and that
      halfedges have the right next, twin, vertex, edge, and face pointers
      reassigned.
      <br /><br />
      One implementation trick is to first assign a variable to each mesh
      element by traversing the halfedge datastructure and name it as you have
      done in the diagram. This just makes the reassignment step much easier.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/teapot_before_flips.png" width="400px" />
              <figcaption>Before edge flips.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/teapot_after_flips.png" width="400px" />
              <figcaption>After edge flips.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Part 5: Edge split</h3>

      Edge splits are implemented similarly to edge flips, since both only
      require reassignments to mesh element pointers. The only difference here
      is that edge splits involves creating new mesh elements. That said, we can
      employ the same technique used last time of drawing a diagram, naming
      variables, and assigning each property accordingly. This works because we
      can assume that pointers are assigned correctly and in a consistent manner
      (i.e. same rotation). So, as long as we maintain that state, we can
      generalize the pointer assignments to the diagram.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/before_splits.png" width="400px" />
              <figcaption>Before edge splits.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/after_splits.png" width="400px" />
              <figcaption>After edge splits.</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/after_splits.png" width="400px" />
              <figcaption>Before flips and splits.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/after_flips_and_splits.png" width="400px" />
              <figcaption>After flips and splits.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <br /><br />

      Another part where edge splits differ from edge flips is that it can work
      on boundary edges.

      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/car_before_splits.png" width="400px" />
              <figcaption>Before edge splits.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/car_after_splits.png" width="400px" />
              <figcaption>After edge splits.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Part 6: Loop subdivision for mesh upsampling</h3>

      When implementing loop subdivision, it's easier to first compute (but not
      update) the new vertex positions for both original vertices and the new
      ones that will be born at the midpoint of edges as a result of edge
      splits. Then, we can subdivide by splitting all original edges then
      flipping every new edge that connects a new vertex with an old vertex.
      Finally, we can go ahead and update the positions of the vertices.
      <br /><br />
      It's important to note that existing edges are cut in half after an edge
      split, and its other half should be handled carefully. First, it should
      not split again, so it should be grouped as a "new edge" in this sense.
      That said, it should also not be flipped, because it's technically part of
      the "old edge" as well. The approach that I employed is to not count it as
      a new edge, and only iterating on a list of original edges, which we can
      build as we compute the new positions for midpoint-bound vertices.
      <br /><br />

      After upsampling, meshes generally become smoother and less jagged.
      However, this can also be an unfortunate side effect for some sharp edges
      that we intend to keep, like in the case of a cube. As seen in the example
      below, upsampling can crumble the intended shape of the object.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/before_upsample.png" width="400px" />
              <figcaption>Before upsampling.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/after_upsample.png" width="400px" />
              <figcaption>After upsampling.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <br /><br />

      It does seem that splitting the edges before upsampling can help maintain
      the structure a bit better though.

      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/split_before_upsample.png" width="400px" />
              <figcaption>Edge-split cube, before upsampling.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/split_after_upsample.png" width="400px" />
              <figcaption>Edge-split cube, after upsampling.</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <br /><br />
      If we apply more splits strategically, the shape of the cube seems to
      retain better after upsampling.
      <br /><br />

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/symcube_before.png" width="400px" />
              <figcaption>Before upsampling.</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/symcube_after.png" width="400px" />
              <figcaption>After upsampling.</figcaption>
            </td>
          </tr>
        </table>
      </div>
      <br /><br />
      This is likely because the added splitting creates more triangles, which
      give the cube more structure, preventing it from being lost to the
      upsampling process.
    </div>
  </body>
</html>
